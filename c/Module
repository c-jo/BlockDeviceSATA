/*
 * Copyright (c) 2025, Chris Johns
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of the copyright holder nor the names of their
 *       contributors may be used to endorse or promote products derived from
 *       this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <stdint.h>
#include <stdbool.h>
#include <string.h>
#include <time.h>

#include "BlockDeviceSATAHdr.h"
#include "SATADevice.h"

#include "swis.h"

#include "Global/NewErrors.h"
#include "Global/Services.h"
#include "Global/OSMisc.h"

#include "SyncLib/synclib.h"
#include "DebugLib/DebugLib.h"

#include "Interface/ATA.h"
#include "ATA.h"

#undef ATA_Initialise
#define ATA_Initialise 0x00059780
#undef ATA_Control
#define ATA_Control 0x00059781
#undef ATA_Enumerate
#define ATA_Enumerate 0x00059782
#undef ATA_Op
#define ATA_Op 0x00059783
#undef ATA_PacketOp
#define ATA_PacketOp 0x00059784

sata_device_t *sata_devices = NULL;

static _kernel_oserror err_UnknownDevice = {
  .errnum = 1,
  .errmess = "Unknown device"
};

/* A quick macro to silence compiler warnings about unused parameters */
#define IGNORE(x) do { (void)(x); } while(0)

static void get_string(uint16_t* ptr, char* buffer, unsigned size)
{
  memcpy(buffer, ptr, size);
  int i;
  for (i = 0; i < size; i += 2)
  {
    buffer[i+1] ^= buffer[i  ];
    buffer[i  ] ^= buffer[i+1];
    buffer[i+1] ^= buffer[i  ];
  }

  buffer[size] = 0;
  bool end=true;
  for (i = size; i >= 0; --i)
  {
    if (buffer[i] <= ' ' || buffer[i] > 127)
      buffer[i] = end ? 0 : ' ';
    else
      end = false;
  }
}

static _kernel_oserror *identify_sata_device(unsigned handle, unsigned spec, unsigned port_id, unsigned device_id)
{
  uint32_t status, remain;
  ataop_param_lba28_t params = {
    .device = DEVICE_MAGIC,
    .command = ATACOMMAND_IDENTIFY_DEVICE
  };

  uint16_t info[256];

  _kernel_oserror *e = _swix(ATA_Op, _INR(0,5)|_OUT(0)|_OUT(4),
               ATAOp_NoDRDY |
                  (device_id << ATAOp_DeviceIDShift) |
                  (port_id << ATAOp_CPIDShift) |
                  ATAOp_TransRead,
               7,
               (uint8_t *) &params,
               (uint8_t *) &info,
               sizeof info,
               100,
               &status, &remain);

  if (e)
    printf("  error:%s\n", e->errmess);
  else
    printf("  status:%x remain:%x\n", status, remain);

  /* Check if 48-bit addressing is supported */
  bool lba48 = (info[83] & 0xc000) == 0x4000 && (info[83] & (1 << 10));

  /* Determine the number of sectors */
  uint64_t sectors = lba48 ? *((uint64_t*)&info[100]) : *((uint32_t*)&info[60]);

  /* Default sector size */
  unsigned sector_size = 512;

  /* Sector size not 512 bytes? */
  if ((info[106] & 0xc000) == 0x4000 && (info[106] & 1<<12)) {
      sector_size = (info[117] + (info[118] * 65536)) * 2;
  }

  /* Create a new SATA device structure */
  sata_device_t *device = malloc(sizeof(sata_device_t));
  if (!device) {
    return _kernel_last_oserror();
  }

  /* Initialize the device structure */
  device->block_device_id = 0;
  device->port_id = port_id;
  device->device_id = device_id;
  device->sectors = sectors;
  device->sector_size = sector_size;
  device->lba48 = lba48;

  get_string(info+27, device->model, 40);
  get_string(info+23, device->firmware, 8);

  /* Initialize the device info structure */
  device->info.name = "sata";
  device->info.flags = 0;
  device->info.interface_type = BlockDevice_InterfaceType_SATA;
  device->info.interface_connection = BlockDevice_InterfaceConnection_Unknown;
  device->info.media_type = BlockDevice_MediaType_HardDisc;
  device->info.parent_device = 0;
  device->info.block_count = sectors;
  device->info.block_size = sector_size;
  device->info.description = device->model;

  /* Add to the linked list */
  device->next = 0;
  if (sata_devices == NULL)
  {
    sata_devices = device;
  }
  else
  {
    sata_device_t *last = sata_devices;
    while (last->next != NULL) last=last->next;
    last->next = device;
  }

  printf("%lld sectors of %d bytes\n", sectors, sector_size);

  return e;
}


static void register_devices(void *pw)
{
  sata_device_t *device = sata_devices;
  while (device) {
    if (device->block_device_id == 0) {
      _kernel_oserror *e = _swix(BlockDevice_Register, _INR(1,3)|_OUT(0),
                                  &device->info,
                                  driver_entry, pw,
                                  &device->block_device_id);
      if (e) {
        dprintf(("", "Failed to register SATA %d/%d device: %s\n", device->port_id, device->device_id, e->errmess));
      } else {
        dprintf(("", "Registered SATA device %d/%d with ID %d\n", device->port_id, device->device_id, device->block_device_id));
      }
    }
    device = device->next;
  }
}

_kernel_oserror *module_initialise(const char *cmd_tail, int podule_base, void *pw)
{
  synclib_init();

  /* set up debugging */
  debug_initialise(Module_Title, "<BlockDeviceSTA$DebugLog>", "");
  //debug_set_device(FILE_OUTPUT);
  //debug_set_device(HAL_OUTPUT);
  debug_set_device(PRINTF_OUTPUT);
  debug_set_stamp_debug(FALSE);

  IGNORE(cmd_tail);
  IGNORE(podule_base);
  IGNORE(pw);

  unsigned handle=0, spec;

  while (
    0 == _swix(ATA_Enumerate, _INR(0,1)|_OUTR(1,2),
               ATAEnumerate_Drives, handle, &handle, &spec)
    && 0 != handle)
  {
    if (!(spec & ATAEnumerate_PacketDevice))
    {
      unsigned port_id   = (spec & ATAEnumerate_CPIDMask)     >> ATAEnumerate_CPIDShift;
      unsigned device_id = (spec & ATAEnumerate_DeviceIDMask) >> ATAEnumerate_DeviceIDShift;

      _kernel_oserror *e = identify_sata_device(handle, spec, port_id, device_id);
      if (e) {
        printf("Unable to identify drive.\n");
      }
    }
  }

  register_devices(pw);
  return 0;
}

_kernel_oserror *module_finalise(int fatal, int podule, void *pw)
{
  IGNORE(fatal);
  IGNORE(podule);

sata_device_t *device = sata_devices;
while (device) {
  sata_device_t *next = device->next;
  if (device->block_device_id != 0) {
    _swix(BlockDevice_Deregister, _IN(0), device->block_device_id);
  }
  free(device);
  device = next;
}
sata_devices = NULL;

return 0;
}

void module_service(int service, _kernel_swi_regs *r, void *pw)
{
  IGNORE(r);

  switch (service)
  {
    case Service_BlockDevices_Started:
      dprintf(("", "Service_BlockDevices_Started\n"));
      register_devices(pw);
      break;

    case Service_BlockDevices_Dying:
      dprintf(("", "Service_BlockDevices_Dying\n"));
      sata_device_t *device = sata_devices;
      while (device) {
        device->block_device_id = 0;
        device = device->next;
      }
      break;
  }
}

static sata_device_t *find_sata_device(unsigned block_device_id)
{
  sata_device_t *device = sata_devices;
  while (device) {
    if (device->block_device_id == block_device_id) {
      return device;
    }
    device = device->next;
  }
  return NULL;
}

static _kernel_oserror *sata_transfer_lba48(sata_device_t *device, uint64_t lba, size_t count, void *address, unsigned direction, unsigned *status, unsigned *remain)
{
  ataop_param_lba48_t params = {
    .features = 0,
    .device   = DEVICE_MAGIC | DEVICE_LBA,
    .command  = ATACOMMAND_READ_DMA_EXT,
    .lba      = {
      (lba >>  0) & 0xff,
      (lba >>  8) & 0xff,
      (lba >> 16) & 0xff,
      (lba >> 24) & 0xff,
      (lba >> 32) & 0xff,
      (lba >> 40) & 0xff
    },
    .count    = (count == 65536) ? 0 : count
  };

  return _swix(ATA_Op, _INR(0,5)|_OUT(0)|_OUT(4),
              (device->device_id << ATAOp_DeviceIDShift) |
              (device->port_id << ATAOp_CPIDShift) |
              direction,
              sizeof params,
              &params,
              address,
              count * device->sector_size,
              100,
              status, remain);
}

static _kernel_oserror *sata_transfer_lba24(sata_device_t *device, uint64_t lba, size_t count, void *address, unsigned direction, unsigned *status, unsigned *remain)
{
  ataop_param_lba28_t params = {
    .features = 0,
    .device   = DEVICE_MAGIC | DEVICE_LBA,
    .command  = ATACOMMAND_READ_DMA,
    .lba      = {
      (lba >>  0) & 0xff,
      (lba >>  8) & 0xff,
      (lba >> 16) & 0xff
    },
    .count    = (count == 256) ? 0 : count
  };

  return _swix(ATA_Op, _INR(0,5)|_OUT(0)|_OUT(4),
              (device->device_id << ATAOp_DeviceIDShift) |
              (device->port_id << ATAOp_CPIDShift) |
              direction,
              7,
              &params,
              address,
              count * device->sector_size,
              100,
              &status, &remain);
}

static _kernel_oserror *sata_read(sata_device_t *device, transfer_block_t *transfer)
{
  uint32_t status, remain;
  _kernel_oserror *e = NULL;

  _swix(ATA_Control, _INR(0,1), ATAControl_Lock, (device->port_id << ATAControl_CPIDShift) | (device->device_id << ATAControl_DeviceIDShift));

  dprintf(("", "sata: LBA:%lld READ %d bytes to %p\n",
     transfer->lba, transfer->count * device->sector_size, transfer->address));

  while (transfer->count > 0 && e == NULL) {

    dprintf(("", "%d blocks to go. lba:%llx, address:%p\n", transfer->count, transfer->lba, transfer->address));

    unsigned this_count = transfer->count;
    if (device->lba48) {
      if (this_count > 65536) this_count = 65536;
      e = sata_transfer_lba48(device, transfer->lba, this_count, transfer->address, ATAOp_TransRead, &status, &remain);
    } else {
      if (this_count > 256) this_count = 256;
      e = sata_transfer_lba24(device, transfer->lba, this_count, transfer->address, ATAOp_TransRead, &status, &remain);
    }


    dprintf(("", "    : status:%d remain:%d. %s\n",
                status, remain, e ? e->errmess : "OK."));

    if (e == NULL) {
      transfer->count -= this_count;
      transfer->lba   += this_count;
      transfer->address = (char *)transfer->address + (this_count * device->sector_size);
    }
  }

  _swix(ATA_Control, _INR(0,1), ATAControl_Unlock, (device->port_id << ATAControl_CPIDShift) | (device->device_id << ATAControl_DeviceIDShift));

  return e;

}

_kernel_oserror *driver_handler(_kernel_swi_regs *r, void *pw)
{
  dprintf(("", "driver_handler for op %d on device %d\n", r->r[8], r->r[0]));

  sata_device_t *device = find_sata_device(r->r[0]);
  if (!device) return &err_UnknownDevice;

  switch (r->r[8]) {
  case BlockDevices_Reason_Read:
    return sata_read(device, (transfer_block_t *)r->r[2]);
  case BlockDevices_Reason_Write:
  case BlockDevices_Reason_Verify:
    //return nvme_io(r->r[8], device, 0, (transfer_block_t *)r->r[2], pw);
  case BlockDevices_Reason_DeviceOp:
    //return nvme_device_op(device, r, pw);
  case BlockDevices_Reason_MediaOp:
    //return nvme_media_op(device, r, pw);
  case BlockDevices_Reason_SectorOp:
    //return nvme_sector_op(device, r, pw);
  case BlockDevices_Reason_DriverOp:
    //return nvme_driver_op(device, r->r[2],
    //                      (nvme_sqe_t*)r->r[3], (nvme_cqe_t*)r->r[4]);
  default:
    return 0;//&err_BadReason;
  }
}
